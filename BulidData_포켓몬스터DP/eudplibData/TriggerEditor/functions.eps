

/* ------------------------------------------------------------------------------
  전역 함수
  
  - 
  - 
  - 
------------------------------------------------------------------------------ */

const s = StringBuffer(1024);

function SetNextUnitPTR(){
    return cunitepdread_epd(EPD(0x628438))[[0]];
}

function SetNextUnitEPD(){
    return cunitepdread_epd(EPD(0x628438))[[1]];
}

function SetNextUnit(){
    return cunitepdread_epd(EPD(0x628438));
}

function IndexToEPD(index){
    if(index == 0) {
        return 19025;
    } else {
        return 161825 - (84 * index);
    }
}

function SingleBan(){
    const a = 0x6D0F48; //방이름
    const b = 0x6D0F78; //방장닉
    const c = Db("");
    if(strcmp(a, b) == 0){
        foreach(cp : EUDLoopPlayer('Human', None, None)){
            setcurpl(cp); s.print("\x13\x1EUDP 플레이는 금지하고 있습니다.\n\x13\x04배틀넷에서 플레이하세요."); Defeat();
        }
    }
    else if(strcmp(b, c) == 0){
        foreach(cp : EUDLoopPlayer('Human', None, None)){
            setcurpl(cp); s.print("\x13\x1E싱글 플레이는 금지하고 있습니다.\n\x13\x04배틀넷에서 플레이하세요."); Defeat();
        }
    }
    /*for(var i=0; i<6; i++){
        const d = 0x57EEEB + 36 * i;
        if(strcmp(b, d) == 0){SetVariables(sys.setUser, i); SetDeaths(i, SetTo, 1, 215); break;}
    }*/
}


function SpeedBan(){
    const a = dwread_epd_safe(EPD(0x51CE84));
    const b = dwread_epd_safe(EPD(0x51CE88));
    if(a == 1000){if(b == 1000) return;}		//턴레이트24
    else if(a == 1042){if(b == 1190) return;}	//턴레이트20
    else if(a == 1302){if(b == 1488) return;}	//턴레이트16
    else if(a == 1488){if(b == 1701) return;}	//턴레이트14
    else if(a == 1736){if(b == 1984) return;}	//턴레이트12
    else if(a == 2083){if(b == 2381) return;}	//턴레이트10
    else if(a == 2604){if(b == 2976) return;}	//턴레이트8
    else{
        foreach(cp : EUDLoopPlayer('Human', None, None)){
            setcurpl(cp);
            s.print("\x13\x1E배속 플레이는 금지하고 있습니다.\n\x13\x04방제목에 있는 배속을 빼주세요.");
            Defeat();
        }
    }
}

function exitObserver(){
    for(var i=0; i<4; i++){
        if(getuserplayerid() == 128+i){
            setcurpl(getuserplayerid());
            s.print("  \x08■ \x04죄송합니다, 이 유즈맵은 관전을 비허용하고 있습니다.");
            EUDPlayerLoop()();
            Defeat();
            EUDEndPlayerLoop();
        }
    }
}

function ComputerCheck(player){
    if(MemoryX(0x57EEE8+ 0x24*player, Exactly, 2, 0x000000FF)){ //해당플레이어가 유저인 경우
        for(var i=0; i<8; i++){
            setcurpl(i); if(IsUserCP()){if(Memory(0x000000, Exactly, 0)){Defeat();}}
        }
    }
}

function scanEffect(targetLoc:TrgLocation, targetImage){
    SetMemoryX(0x666458, SetTo, targetImage, 0xFFFF);
    CreateUnit(1, "Scanner Sweep", targetLoc, 7);
    KillUnit("Scanner Sweep", 7);
}

function GetDeath(player, unit:TrgUnit){
    return dwread_epd(player + 12 * unit);
}

function ButtonRefresh(){
    const epd = SetNextUnitEPD();
    CreateUnit(1, 45, "[Button]Refresh", 7);
    SetMemoryXEPD(epd+68, SetTo, 1, 0xFFFF);
}

function hypot(x, y){
    var t = 0;
    if(!(x >= y)){ t = x; x = y; y = t; } //Swap x, y so that y <= x
    var d = y + y - x;
    if(d >= 0x80000000) d=0;
    d += y;
    t = x + d / 5;
    return t;
}

function __GetLocCoord(loc: TrgLocation) {
    const loc_epd = loc * 5;
    DoActions(loc_epd.AddNumber(EPD(0x58DC4C)));
    const x1 = dwread_epd(loc_epd);
    DoActions(loc_epd.AddNumber(1));
    const y1 = dwread_epd(loc_epd);
    DoActions(loc_epd.AddNumber(1));
    const x2 = dwread_epd(loc_epd);
    DoActions(loc_epd.AddNumber(1));
    const y2 = dwread_epd(loc_epd);
    return x1, y1, x2, y2;
}

function LocationDistance(loc1, loc2) {
    const ox1, oy1, ox2, oy2 = __GetLocCoord(loc1);
    const dx1, dy1, dx2, dy2 = __GetLocCoord(loc2);
    const x1 = ox1 + ox2;
    const y1 = oy1 + oy2;
    const x2 = dx1 + dx2;
    const y2 = dy1 + dy2;
    var x, y;
    if(x1 > x2) x = x1 - x2;
    else x = x2 - x1;
    if(y1 > y2) y = y1 - y2;
    else y = y2 - y1;
    return hypot(x, y);
    //return sqrt((x1 - x2)*(x1 - x2)+(y1-y2)*(y1-y2)) / 2;
}

function CheckNoneTargetSkillEPD(
    cp,
    unitEPD,
    range,
    unitLoc: TrgLocation,
    targetLoc: TrgLocation,
    skillOrder /*Order*/
) {
    unitEPD += 0x4D/4;
    if (MemoryXEPD(unitEPD, Exactly, skillOrder, 0xFF00)) { //order는 256을 곱한 값을 사용함
        unitEPD += -((0x4D - 0x28)/4);
        const x, y = posread_epd(unitEPD);
        setloc(unitLoc, x, y);
        unitEPD += (0x58 - 0x28)/4;
        setloc_epd(targetLoc, unitEPD);

        if (range > LocationDistance(unitLoc, targetLoc)) {
            MoveLocation(targetLoc, 227, AllPlayers, targetLoc);
            unitEPD += -((0x58 - 0x4C)/4);
            SetMemoryXEPD(unitEPD, SetTo, 0x100, 0xFF00);
            unitEPD += -((0x4D - 0x10)/4);
            SetMemoryEPD(unitEPD, SetTo, x + y * 65536);
            return True;
        }
    }
    return False;
}

function AttackGround(
    attackLoc: TrgLocation,
    targetLoc: TrgLocation,
    attackUnit: TrgUnit,
    targetUnit: TrgUnit,
    player: TrgPlayer
) {
    if (Memory(0x628438, Exactly, 0)) return;  // avoid EUDError when CCMU
    const aUnit = cunitepdread_epd(EPD(0x628438))[[1]];
    CreateUnit(1, attackUnit, attackLoc, player);
    DoActions(aUnit.AddNumber(0x110 / 4));
    SetMemoryEPD(aUnit, Add, 2);  // aUnit + 0x110 (CUnit::removeTimer)

    if (Memory(0x628438, Exactly, 0)) return;  // avoid EUDError when CCMU
    const tunitptr, tunit = cunitepdread_epd(EPD(0x628438));
    CreateUnit(1, targetUnit, targetLoc, player);
    DoActions(list(
        tunit.AddNumber(0x110 / 4),
        aUnit.AddNumber(-((0x110 - 0x5C) / 4))
    ));
    SetMemoryEPD(aUnit, SetTo, tunitptr);  // aUnit + 0x5C (CUnit::targetUnit)
    SetMemoryEPD(tunit, Add, 2);  // tunit + 0x110 (CUnit::removeTimer)

    DoActions(aUnit.AddNumber(-((0x5C - 0x4C) / 4)));
    SetMemoryXEPD(aUnit, SetTo, 0xA00, 0xFF00);  // order[10]=attack, 0x4D (CUnit::order)
}

function AttackTargetPTR(cp, createLoc, targetPTR, attackUnit){
    const aUnit = SetNextUnitEPD();
    CreateUnit(1, attackUnit, createLoc, cp);
    DoActions(aUnit.AddNumber(0x110 / 4));
    SetMemoryEPD(aUnit, Add, 2);  // aUnit + 0x110 (CUnit::removeTimer)
    DoActions(aUnit.AddNumber(-((0x110 - 0x5C) / 4)));
    SetMemoryEPD(aUnit, SetTo, targetPTR);
    DoActions(aUnit.AddNumber(-((0x5C - 0x4C) / 4)));
    SetMemoryXEPD(aUnit, SetTo, 0xA00, 0xFF00);
}

function LocationAngle(originLoc, destLoc){
    const ox1, oy1, ox2, oy2 = __GetLocCoord(originLoc);
    const dx1, dy1, dx2, dy2 = __GetLocCoord(destLoc);
    const x1 = ox1 + ox2;
    const y1 = oy1 + oy2;
    const x2 = dx1 + dx2;
    const y2 = dy1 + dy2;
    var transAngle = atan2(x2 - x1, y1 - y2);
    if(transAngle>90){transAngle -= 90;}
    else{transAngle += 270;}
    return transAngle;
}

function PolarLocation(loc: TrgLocation, length, angle){
    const x, y = lengthdir(length, angle);
    addloc(loc, x, y);
}

function BringEPD(unitEPD, location: TrgLocation, dummyUnit: TrgUnit) {
    MoveLocation(location, dummyUnit, AllPlayers, location);
    const unitType = unitEPD + 0x64/4;
    const originalUnitType = maskread_epd(unitType, 0xFFFF);
    SetMemoryXEPD(unitType, SetTo, dummyUnit, 0xFFFF);
    const ret = l2v(Bring(AllPlayers, AtLeast, 1, dummyUnit, location));
    SetMemoryXEPD(unitType, SetTo, originalUnitType, 0xFFFF);
    return ret;
}

function BuildCheckEPD(unitEPD, unit: TrgUnit) {
    unitEPD += 0x98 / 4;  // buildQueue
    if (MemoryXEPD(unitEPD, Exactly, unit, 0xFFFF)) {
        return True;
    } else {
        const mulUnit = unit * 65536;
        if (MemoryXEPD(unitEPD, Exactly, mulUnit, 0xFFFF0000)) {
            return True;
        } else {
            unitEPD += 1;
            if (MemoryXEPD(unitEPD, Exactly, unit, 0xFFFF)) {
                return True;
            } else if (MemoryXEPD(unitEPD, Exactly, mulUnit, 0xFFFF0000)) {
                return True;
            } else {
                unitEPD += 1;
                if (MemoryXEPD(unitEPD, Exactly, unit, 0xFFFF)) {
                    return True;
                }
            }
        }
    }
    return False;
}

function BuildResetEPD(unitEPD) {
    VProc(unitEPD, list(
        unitEPD.AddNumber(0x98/4),
        unitEPD.SetDest(EPD(0x6509B0)),
    ));
    setcurpl2cpcache(actions=list(
        SetDeaths(CurrentPlayer, SetTo, 0xE400E4, 0),
        SetMemory(0x6509B0, Add, 1),
        SetDeaths(CurrentPlayer, SetTo, 0xE400E4, 0),
        SetMemory(0x6509B0, Add, 1),
        SetDeathsX(CurrentPlayer, SetTo, 228, 0, 0xFFFF),
        SetMemory(0x6509B0, Add, 1),
        SetDeathsX(CurrentPlayer, SetTo, 2 << 16, 0, 0xFFFF0000),
    ));
}

function CheckUnit(player, unit){
    if(MemoryEPD(EPD(0x582324) + 12 * unit + player, Exactly, 0)){return False;}
    return True;
}

function ToggleUnitAvailability(player, unit){
    var dst = 0x57F27C + player*228 + unit;
    const q, r = div(dst - 0x58A364, 4);
    const v = bitlshift(1, 8 * r);
    SetMemoryXEPD(q, Add, v, v);
}

function calculateDigits(val1, val2){
    var temp = (val1*100)/val2;
    var sec = 0;
    while(temp >= 100){temp -= 100; sec += 1;}
    const decimal = temp;
    return sec, decimal; //초와 소수점 따로 분리.
}

function SetPColor(pnum, color){
    const pcolor_dst = 0x581D76 + 8 * pnum;
    const mcolor_dst = 0x581DD6 + pnum;
    bwrite(pcolor_dst, color);
    bwrite(mcolor_dst, color);
}

function __SpawnBase(epd, unit: TrgUnit, newUnit: TrgUnit) {
    if (
        MemoryXEPD(epd + 0x64/4, Exactly, unit, 0xFFFF)
        && MemoryXEPD(epd + 0x4E/4, Exactly, 0, 0xFF0000)
    ) {
        SetMemoryXEPD(epd + 0x4D/4, SetTo, (42 << 8) + (1 << 16), 0xFFFF00);
        SetMemoryXEPD(epd + 0x98/4, SetTo, newUnit, 0xFFFF);
    }
}

function SpawnEggEPD(epd, newUnit: TrgUnit) {
    __SpawnBase(epd, 36, newUnit);
}

function __LocOrderBase(
    epd,
    order_lsh8,
    loc: TrgLocation
) {
    const loc_epd = loc * 5;
    DoActions(loc_epd.AddNumber(EPD(0x58DC4C)));

    const x1 = dwread_epd(loc_epd);
    DoActions(loc_epd.AddNumber(1));
    const y1 = dwread_epd(loc_epd);
    DoActions(loc_epd.AddNumber(1));
    const x2 = dwread_epd(loc_epd);
    DoActions(loc_epd.AddNumber(1));
    const y2 = dwread_epd(loc_epd);

    const x = (x1 + x2) / 2;
    const y = (y1 + y2) << 15;  // = (y1 + y2) / 2 * 65536 

    epd += 0x4D / 4;
    SetMemoryXEPD(epd, SetTo, order_lsh8, 0xFF00);
    epd += (0x58 - 0x4C) / 4;
    SetMemoryEPD(epd, SetTo, y + x);
}

function COrderLocEPD(epd, order, loc: TrgLocation) {
    __LocOrderBase(epd, order << 8, loc);
}

function setLight(value){
    if(IsUserCP())SetMemoryEPD(EPD(0x657A9C), SetTo, value);
}