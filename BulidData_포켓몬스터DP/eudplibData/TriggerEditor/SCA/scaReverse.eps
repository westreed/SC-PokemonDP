import Interface.menu_Book as imk;
import Interface.menu_Bag as imb;
import Pokemon.calculateMethod as pcm;
import Pokemon.myPokemon as pmp;
import Player.playerSetting as pps;
import Player.playerUnit as ppu;
import dataTable as dT;
import scaVariable as sv;

/*
const scaMain		= PVariable();
const scaSub		= EUDArray(8*5);
const scaTrainer	= EUDArray(8*5);
const scaPokemonIL	= EUDArray(8*pmp.userPokemonNum); //(index + 256*level)
const scaPokemonHP	= EUDArray(8*pmp.userPokemonNum);
const scaPokemonIVs	= EUDArray(8*pmp.userPokemonNum);
const scaPokemonEXP	= EUDArray(8*pmp.userPokemonNum);
const scaPokemonIS	= EUDArray(8*pmp.userPokemonNum); //(item + 256*state)
const scaBag		= EUDArray(8*imb.bagMax);
const scaBook		= EUDArray(8*5); const sinoBook      = EUDArray(4*156);
const scaLocation	= PVariable(); //lastVisitVillage + 256*lastVisitHeal*/

//유즈맵데이터를 SCA데이터로 변환하기
function map2sca(cp){
    sv.scaMain[cp] = pps.mainStory[cp];
    //sv.scaSub[cp]
    //sv.scaTrainer[cp]
    const cpPk = cp*pmp.userPokemonNum;
    for (var i=0; i<pmp.userPokemonNum; i++){
        const mpk = pmp.myPokemon.cast(pmp.playerPokemonList[cpPk+i]);
        sv.scaPokemonIL[cpPk+i] = mpk.index + mpk.level*256;
        sv.scaPokemonHP[cpPk+i] = mpk.hitpoint;
        sv.scaPokemonIVs[cpPk+i] = mpk.IVs;
        sv.scaPokemonEXP[cpPk+i] = mpk.ownEXP;
        sv.scaPokemonIS[cpPk+i] = mpk.item + mpk.state*256;
    }
    const cpBg = cp*imb.bagMax;
    for (var i=0; i<imb.bagMax; i++){
        sv.scaBag[cpBg+i] = imb.bagItemList[cpBg+i] + imb.bagNumList[cpBg+i]*256;
    }
    const cpBk = cp*imk.bookSCANum;
    const cpBn = cp*imk.pageNumber;
    for (var i=0; i<imk.bookSCANum; i++){
        const i32 = i*32;
        for (var j=0; j<32; j++){sv.scaBook[cpBk + i] += imk.sinoBook[cpBn+i32+j]*dT.bit32[j];}
    }
    sv.scaLocation[cp] = pps.lastVisitVillage[cp] + pps.lastVisitHeal[cp]*256 + pps.currentLocation[cp]*65536;
    sv.scaPosition[cp] = ppu.playerPosX[cp] + ppu.playerPosY[cp]*8192;
}

//SCA데이터를 유즈맵데이터로 변환하기
function sca2map(cp){
    pps.mainStory[cp] = sv.scaMain[cp];

    const cpPk = cp*pmp.userPokemonNum;
    for (var i=0; i<pmp.userPokemonNum; i++){
        const mpk = pmp.myPokemon.cast(pmp.playerPokemonList[cpPk+i]);
        const scaPokemonIndex, scaPokemonLevel = pcm.divideData256(sv.scaPokemonIL[cpPk+i]);
        mpk.index = scaPokemonIndex;
        mpk.level = scaPokemonLevel;
        mpk.hitpoint = sv.scaPokemonHP[cpPk+i];
        mpk.IVs = sv.scaPokemonIVs[cpPk+i];
        mpk.ownEXP = sv.scaPokemonEXP[cpPk+i];
        const scaPokemonItem, scaPokemonState = pcm.divideData256(sv.scaPokemonIS[cpPk+i]);
        mpk.item = scaPokemonItem;
        mpk.state = scaPokemonState;
    }

    const cpBg = cp*imb.bagMax;
    for (var i=0; i<imb.bagMax; i++){
        const scaBagItem, scaBagNum = pcm.divideData256(sv.scaBag[cpBg+i]);
        imb.bagItemList[cpBg+i] = scaBagItem;
        imb.bagNumList[cpBg+i] = scaBagNum;
    }

    const cpBk = cp*imk.bookSCANum;
    const cpBn = cp*imk.pageNumber;
    for (var i=0; i<imk.bookSCANum; i++){
        const i32 = i*32;
        for (var j=32; 0<j; j--){
            if(sv.scaBook[cpBk + i] >= dT.bit32[j-1]){sv.scaBook[cpBk + i] -= dT.bit32[j-1]; imk.sinoBook[cpBn+i32+j-1] = 1;}
            else{imk.sinoBook[cpBn+i32+j-1] = 0;}
        }
    }
    const scaVillage, scaHeal, scaLoc, scaTemp = pcm.divideStats(sv.scaLocation[cp]);
    pps.lastVisitVillage[cp] = scaVillage;
    pps.lastVisitHeal[cp] = scaHeal;
    pps.currentLocation[cp] = scaLoc;
    const scaPosX, scaPosY = pcm.dividePos(sv.scaPosition[cp]);
    ppu.playerPosX[cp] = scaPosX;
    ppu.playerPosY[cp] = scaPosY;
}